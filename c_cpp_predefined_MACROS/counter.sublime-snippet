<!-- 
gnu:

This macro expands to sequential integral values starting from 0. In conjunction with the ## operator, this provides a convenient means to generate unique identifiers. Care must be taken to ensure that __COUNTER__ is not expanded prior to inclusion of precompiled headers which use it. Otherwise, the precompiled headers will not be used. 

windows:

Expands to an integer literal starting with 0 and incrementing by 1 every time it is used in a source file or included headers of the source file. __COUNTER__ remembers its state when you use precompiled headers.

The following example uses __COUNTER__ to assign unique identifiers to three different objects of the same type.

First, assume the following class definition. The constructor takes an integer as a parameter.
C++

// initialize object with a read-only unique ID
exampleClass::exampleClass(int nID)
{
	m_nID = nID;
}

int exampleClass::GetID()
{
	return m_nID;
}

In main, the application declares three objects of type exampleClass, using __COUNTER__ as the unique identifier parameter.
C++

// Demonstration of __COUNTER__, assigns unique identifiers to
//  different objects of the same type
int main(int argc, char** argv)
{
	// __COUNTER__ is initially defined as 0
	exampleClass e1(__COUNTER__);

	// having been referenced, __COUNTER__ is now defined as 1
	exampleClass e2(__COUNTER__);

	// __COUNTER__ is now defined as 2
	exampleClass e3(__COUNTER__);

	printf("e1 ID: %i\n", e1.GetID());
	printf("e2 ID: %i\n", e2.GetID());
	printf("e3 ID: %i\n", e3.GetID());

	// Output
	// ------------------------------
	// e1 ID: 0
	// e2 ID: 1
	// e3 ID: 2

	return 0;
}


-->
<snippet>
	<content><![CDATA[
__COUNTER__
]]></content>
	<tabTrigger>__COUNTER__</tabTrigger>
	<scope>source.c, source.c++</scope>
	<description>GNU MACRO</description>
</snippet>
